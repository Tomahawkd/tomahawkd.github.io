---
title: 计算机网络
---

<script>document.getElementsByClassName("project-name").item(0).innerText = "{{ page.title }}"</script>
<button onclick="javascript:window.history.back();">&lt; Back</button>

## 名词解释(5x2')

1. 协议：指（对等的）通信双方就如何进行通信的一种约定
2. 带宽：传输过程中振幅不会明显减弱的频率的宽度
3. 汇集树：从所有源到一个指定目标的最优路径集合构成的以目标节点为根的树
4. 隧道技术：隧道将来源的数据包看作数据重新封装发送，直到该数据包到达隧道目标后解包后利用原有的数据报文头继续发送。
5. NAT：网络地址转换。为了解决网络地址不足，内网的主机服务利用IP和端口在NAT设备上进行端口绑定以达到和外网互通的效果。
6. ADSL：非对称数字用户线路。采用频分复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道。非对称指上行下行数据速率不对等。
7. P2P：将一对单独的机器连接起来的传输方式。

## 单选(10x1')

计算机网络、网络划分、网络设备（中继器、集线器、网桥、交换机、路由器、网关）、频分时分波分、上层协议（网络层传输层应用层）、服务质量等（原话送分题）

## 计算(3x5')

1. CRC
   - 数据（低位加(多项式位数-1)个0）÷协商的多项式=商······余数（多项式位数-1位）
2. 信道最大传输速率
   - 有限带宽无噪声信道最大速率=$2B*log_2V$ (bits/s)（B为带宽单位Hz、V为一个信号可以代表数据的个数(离散信号个数)，故$log_2V$为单个信号所带bit数）。
   - 有限带宽有噪声信道最大速率=$B*log_2(1+S/N)$ (bits/s)（噪声db利用$10*log_{10}S/N$表示，即最大速率=$B*log_2(1+10^{db/10})$）
3. 最小帧长度计算
   - 最小帧长=总线传输时延\*数据传输速率\*2
4. 结合以上两个计算
   - 无噪声信道最小帧长=总线长度/电信号速率$*2B*log_2V*2$
   - 有噪声信道最小帧长=总线长度/电信号速率$*B*log_2(1+S/N)*2$
5. CIDR计算

## 简答(5x5') & 论述(4x10')

1. 流量整形（漏桶、令牌桶）

   - 漏桶：无论接收漏桶的数据的速率多大，只要漏桶有数据，那么发送的速率恒定。当漏桶满了后多余的数据丢失
   - 令牌桶：令牌以一个恒定速率生成，当有数据发送时会消耗令牌，当没有令牌的时候无法发送数据

2. 网桥（泛洪、逆向学习、工作过程）

   - 当网桥收到入境帧时：
     - 如果目标地址和源地址的端口相同则抛弃帧
     - 若不同则将帧转发到目标端口
     - 若目标地址未知时利用泛洪算法向所有端口除了源地址端口发送帧
     - 网桥还利用逆向学习算法将源地址和来源端口进行绑定，当以后有发送到该地址的帧时转发到该来源端口
   - 其他：网桥中若发现时间较长的地址-端口对应关系时从表中清除

3. 泛洪算法、RIP（路由矢量）、链路状态路由（可能有算法对比）

   - 泛洪算法：将每一个入境数据包发送到除了来源端口以外的所有端口
     - 网络中会有大量的重复数据包，鲁棒性好

   - RIP/路由矢量：每个路由器维护一张包含已知到每个目标的最佳距离和路径，并通过和邻居的信息交换以获得最优路径
     - 发送矢量，即自己表中到每个目标的最佳距离。收到的矢量加上自己到该节点的距离相加和自己路由表中向量进行对比并更新。
     - 无穷计算：由于发送矢量时没有发送相对应的路径，把从对方获知的，但在对方已不再有效的信息当成有效信息再传送给对方，使对方当成有效信息使用。
   - 链路状态路由：在原有的矢量的基础上，加入了序号、年龄以及下一跳的节点
     - 序号（SEQ）起到过滤重复数据和过期数据；年龄每秒减一使得数据只能存活有限时间，过期即丢弃；下一跳节点则避免了回路的出现；共同避免了无穷计算的出现

4. ARP（Address Resolution Protocol）

5. RED和TCP慢启动

   - RED（Random Early Detection）：当某条链路上的平均队列长度超过了某个阈值，该链路会被认为即将拥塞，路由器会丢弃小部分数据包。
   - TCP慢启动：建立连接时，发送端用较小的值初始化拥塞窗口并发送该窗口大小的数据。当被承认后，该窗口增加一倍。直到到达阈值或者发生超时。若到达阈值，窗口大小就变成以线性增加。若最后发生丢包阈值被设置为当前拥塞窗口的一半，整个过程再重新启动。
   - 联系：开始是主机建立连接并利用TCP慢启动达到一个较高速率时，路由器发现该链路平均队列长度超过阈值，就会随机丢包。而由于该主机发送速度较快，其产生的包较多，也就大概率被丢弃。丢弃后主机发现超时，就会自动重启TCP慢启动而降低传输速率。

6. 电路交换、报文交换、包交换三种方式的比较

   - 电路交换：在数据交换前需要建立一条端到端的路径并预留相应的带宽资源，建立后在数据传输过程中都要保持连接
   - 报文交换：报文直接发出，路由器使用存储转发技术把经过的数据包转发到通往目的地的路径上
   - 包交换（分组交换）：无需建立一条路径和预留的带宽资源，数据包（报文拆分）直接发出，路由器使用存储转发技术把经过的数据包转发到通往目的地的路径上

7. 停等协议和滑动窗口协议

   - 停等协议：
     - 乌托邦式单工协议：简单收发工作，没有流量控制和纠错
     - 无错信道上的单工停等协议：接收方将数据包传递给网络层后给发送方回复一哑帧以允许发送下一帧
     - 有错信道上的单工停等协议：数据帧中加入每个帧的序号以确定该帧是新帧还是重传的老帧。在接收后验证序号是否是期望接收的，若是，则返回确认帧，若不是则不发送直到计时器超时重传。
   - 滑动窗口协议：
     - 1位滑动窗口协议：通信双方在传输数据中维护一个大小为1的滑动窗口用于发送/接收数据，发送方需要发送接收方期待的帧，并等待接收方确认，确认后才能发送下一帧
     - 回退N协议：发送方窗口大于1，接收方是1。当接收方收到一个错误帧，它之后的帧不被接受和确认直到发送方超时重发。
     - 选择重传协议：允许接收方接受并缓存坏帧和丢失帧后的所有帧。在该帧后的一个帧发送NAK请求重传

8. 曼彻斯特编码（举例）

   - 曼彻斯特编码：0低高，1高低
   - 差分曼彻斯特编码：1反相，0不反相

9. WLAN（隐藏站和暴露站问题、CSMA/CA）

   - 隐藏站：在两个互相无法感知的主机给范围内的相同主机发送信息时会发生冲突
   - 暴露站：在两个可以感知的主机给各自范围内的不同主机发送信息时主机会认为发生冲突
   - CSMA/CA：在发送帧前监听信道和检测到冲突后指数后退。
     - 过程
       1. 送出数据前监听信道状态，在没有人使用时维持一段时间后送出数据（每个设备随机时间不同减少冲突）
       2. 送出数据前发送RTS给目标并等待CTS。当接收到CTS时开始传输数据，其他设备利用RTS和CTS维护NAV在一段时间内沉默。
     - 区别（CSMA/CD）
       - CSMA/CD在以太网中使用，由于所有设备在网络上的行为都可以探测到，就可以利用竞争期选出下一个发送数据的设备
       - CSMA/CA则在无线网中使用，由于存在隐藏站和暴露站问题，CD无法有效地选出下一个发送数据的设备，只有利用RTS-CTS握手使在范围内的设备获知信道忙而沉默以避免冲突

10. 多路访问协议（ALOHA、CSMA、CSMA/CD）对比

  - ALOHA

    - 纯ALOHA：当主机有要发送的数据时即发送数据。若冲突则等待一段随机时间再发送
    - 分槽ALOHA：将时间分为离散的间隔，主机发送数据必须等到分槽开始的时候发送，同样在冲突发生时要等待随机时间再发送

  - CSMA

    | 信道状态 | 1-坚持       | 非坚持                       | p-坚持                       |
    | -------- | ------------ | ---------------------------- | ---------------------------- |
    | 空闲     | 立即发送数据 | 立即发送数据                 | 以概率p发送数据，1-p推迟等待 |
    | 忙       | 继续监听信道 | 放弃监听，等待随机时间后监听 | 放弃监听，等待随机时间后监听 |

    - CSMA/CD：首先主机监听信道是否空闲，若不空闲等待随机时间并再次监听，若空闲则发送帧。在发送的过程中若检测到碰撞则立即停止发送，并等待一段随机时间然后再次尝试发送。
    - 二进制指数后退：在等待随机时间时应用的算法。在出现第i次碰撞时，等待时间在0-$2^i-1$中随机选择。在达到第10次冲突后，选择区间最大值被固定为1023。在第16次后则转交给上层处理。

11. TCP连接释放

    - 连接（单方）：
      - SYN(SEQ=x)———SYN(SEQ=y/ACK=x+1)———(SEQ=x+1/ACK=y+1)
    - 连接（双方）：
      - SYN(SEQ=x)———SYN(SEQ=y)———SYN(SEQ=y/ACK=x+1)———SYN(SEQ=x+1/ACK=y+1)
    - 释放：
      - ACK/FIN(可能是两步)———FIN———ACK

12. 报文读取（论述）